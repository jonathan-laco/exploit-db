import discord
import asyncio
from discord.ext import commands
from datetime import datetime
import requests
from bs4 import BeautifulSoup
import random

headers_list = [
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/37.0.2062.94 Chrome/37.0.2062.94 Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',
    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/600.8.9 (KHTML, like Gecko) Version/8.0.7 Safari/600.8.9',
    'Mozilla/5.0 (iPad; CPU OS 8_4_1 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12H321 Safari/600.1.4',
    'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240',
    'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0',
    'Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko',
    'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko',
    'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/600.7.12 (KHTML, like Gecko) Version/8.0.7 Safari/600.7.12',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:40.0) Gecko/20100101 Firefox/40.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/600.7.12 (KHTML, like Gecko) Version/8.0.7 Safari/600.7.12',
    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36',
]

async def get_exploit_data(number):
    url = f'https://www.exploit-db.com/exploits/{number}'
    headers = {'User-Agent': random.choice(headers_list)}
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        source_code = response.text

        # Utiliza o BeautifulSoup para analisar o HTML
        soup = BeautifulSoup(source_code, 'html.parser')

        # Variáveis para armazenar os valores
        og_title = None
        article_published_time = None
        article_author = None
        type_value = None
        platform_value = None
        cve_value = None
        edb_id_value = None

        # Encontra o elemento meta com property="og:title"
        meta_og_title = soup.find('meta', attrs={'property': 'og:title'})
        if meta_og_title:
            og_title = meta_og_title.get('content')

        # Encontra o elemento meta com property="article:published_time"
        meta_article_published_time = soup.find('meta', attrs={'property': 'article:published_time'})
        if meta_article_published_time:
            article_published_time = meta_article_published_time.get('content')

        # Encontra o elemento meta com property="article:author"
        meta_article_author = soup.find('meta', attrs={'property': 'article:author'})
        if meta_article_author:
            article_author = meta_article_author.get('content')

        # Encontra os elementos com a classe "col-6 text-center"
        col_elements = soup.find_all(class_="col-6 text-center")

        for col_element in col_elements:
            # Encontra os elementos "info-title" e "stats-title" dentro de cada elemento "col-6 text-center"
            info_title = col_element.find(class_="info-title")
            stats_title = col_element.find(class_="stats-title")

            if info_title and stats_title:
                # Obtém o texto dos elementos "info-title" e "stats-title"
                info_title_text = info_title.get_text(strip=True)
                stats_title_text = stats_title.get_text(strip=True)

                if "Type" in info_title_text:
                    type_value = stats_title_text
                elif "Platform" in info_title_text:
                    platform_value = stats_title_text
                elif "CVE" in info_title_text:
                    cve_value = stats_title_text
                elif "EDB-ID" in info_title_text:
                    edb_id_value = stats_title_text

        return og_title, article_published_time, article_author, type_value, platform_value, cve_value, edb_id_value
    else:
        return None

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='.', intents=intents)

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    await update_exploit_data()  # Inicia o processo de atualização dos dados dos exploits

async def update_exploit_data():
    number = 51747
    while True:
        exploit_data = await get_exploit_data(number)
        if exploit_data is not None:
            number += 1
            await asyncio.sleep(28800)  # Aguarda 8 horas antes de continuar para a próxima iteração

number = 51747  # Valor inicial do número

@bot.command(name='exploit', help='teste')
async def embed(ctx):
    global number  # Declarando que estamos utilizando a variável global 'number'
    og_title, article_published_time, article_author, type_value, platform_value, cve_value, edb_id_value = await get_exploit_data(number)
    embed = discord.Embed(title=f"NEW EXPLOIT RELEASED! - {og_title}", colour=0xffffff, timestamp=datetime.now())
    embed.set_author(name="InfoHackerSec - Official Red Team Discord", url="https://hackersec.com",icon_url="https://i.imgur.com/vifGpwi_d.jpg?maxwidth=520&shape=thumb&fidelity=high")
    embed.add_field(name="Author", value=f"{article_author}", inline=True)
    embed.add_field(name="EDB-ID", value=f"{edb_id_value}", inline=True)
    embed.add_field(name="CVE", value=f"{cve_value}", inline=True)
    embed.add_field(name="Platform", value=f"{platform_value}", inline=True)
    embed.add_field(name="Type", value=f"{type_value}", inline=True)
    embed.add_field(name="Date", value=f"{article_published_time}", inline=True)
    embed.set_image(url="https://hackersec.com/wp-content/uploads/2021/01/logo_hackersec-min-1920x342.png")
    embed.set_thumbnail(url="https://4siteadvantage.com/wp-content/uploads/2020/04/ExploitDB-Logo.png")
    embed.set_footer(text="Enviado")
    await ctx.send(embed=embed)
    number += 1

@bot.event
async def on_ready():
    print(f'Logged in as {bot.user.name}')
    await send_exploit_message()  # Inicia o envio automático das mensagens

async def send_exploit_message():
    channel = bot.get_channel(TOKEN-AQUI)  # Substitua CHANNEL_ID pelo ID do canal desejado
    while True:
        await embed(channel)
        await asyncio.sleep(28800)

bot.run('')